@startuml seq_node_bc_user
Title Sequence Diagram - Interaction amongst node, blockchain and user.

box "Alice"
actor alice
entity "Alice's\nPerun Node" as alice_node
endbox

entity "Blockchain" as blockchain

box "Bob"
entity "Bob's\nPerun Node" as bob_node
' actor bob
endbox


skinparam sequence {
    messageAlign center
    ArrowThickness 2
    BoxBorderColor Sienna
    BoxBackgroundColor SeaShell
    GroupBodyBackgroundColor transparent
    NoteTextAlignment center
    DefaultTextAlignment center
}
hide footbox

group Establish Session
alice [#DarkBlue]-> alice_node:New Session\n<NewSessionRequest>
alice <-[#DarkBlue] alice_node:New Session\n<NewSessionResponse>
'group
end

group OPEN PHASE
group Open Channel
alice [#DarkBlue]-> alice_node: New Channel\n<NewChannelRequest>
alice_node [#DarkOliveGreen]-> bob_node: New Channel\nNewChannelRequest>
alice_node <-[#DarkOliveGreen] bob_node: New Channel\n<NewChannelResponse>
alice_node [#Crimson]-> blockchain: Fund Channel
blockchain <-[#Crimson] bob_node: Fund Channel
alice_node <-[#Fuchsia] blockchain: Channel Funded
blockchain [#Fuchsia]-> bob_node: Channel Funded
alice <-[#DarkBlue] alice_node: New Channel\n<NewChannelResponse>
'group
end
'group
end

group TRANSACT PHASE
group Transact: Send Payment
alice [#DarkBlue]-> alice_node: Send Payment\n<SendPaymentRequest>
alice_node [#DarkOliveGreen]-> bob_node: Channel Update\n<ChannelUpdateRequest>
alice_node <-[#DarkOliveGreen] bob_node: Channel Update\n<ChannelUpdateResponse>
alice <-[#DarkBlue] alice_node: Send Payment\n<SendPaymentResponse>
'group
end

group Transact: Receive Payment
alice_node <-[#DarkOliveGreen] bob_node: Channel Update\n<ChannelUpdateRequest>
alice <-[#DarkBlue] alice_node: Receive Payment\n<ReceivePaymentRequest>
alice [#DarkBlue]-> alice_node: Receive Payment\n<ReceivePaymentResponse>
alice_node [#DarkOliveGreen]-> bob_node: Channel Update\n<ChannelUpdateResponse>
'group
end

group Transact: Request Payment
alice [#DarkBlue]-> alice_node: Receive Payment\n<ReceivePaymentRequest>
alice_node [#DarkOliveGreen]-> bob_node: Channel Update\n<ChannelUpdateRequest>
alice_node <-[#DarkOliveGreen] bob_node: Channel Update\n<ChannelUpdateResponse>
alice <-[#DarkBlue] alice_node: Receive Payment\n<ReceivePaymentResponse>
'group
end

group Transact: Approve Payment
alice_node <-[#DarkOliveGreen] bob_node: Channel Update\n<ChannelUpdateRequest>
alice <-[#DarkBlue] alice_node: Receive Payment\n<ReceivePaymentRequest>
alice [#DarkBlue]-> alice_node: Receive Payment\n<ReceivePaymentResponse>
alice_node [#DarkOliveGreen]-> bob_node: Channel Update\n<ChannelUpdateResponse>
'group
end
'group
end

group SETTLE PHASE
group Close Channel: Collaborative
alice [#DarkBlue]-> alice_node: Close Channel\n<CloseChannelRequest>
alice_node [#DarkOliveGreen]-> bob_node: Final Channel Update \n<FinalChannelUpdateRequest>
alice_node <-[#DarkOliveGreen] bob_node: Final Channel Update \n<FinalChannelUpdateResponse>
alice_node [#Fuchsia]-> blockchain: Settle Channel (With Final State)
alice_node <-[#Fuchsia] blockchain: Channel Settled
blockchain [#Fuchsia]-> bob_node : Channel Settled
...
Note over blockchain
Immediate
endnote
...
alice_node [#Crimson]-> blockchain: Withdraw Funds
blockchain <-[#Crimson] bob_node: Withdraw Funds 
alice <-[#DarkBlue] alice_node: Close Channel\n<CloseChannelResponse>
'group
end

group Close Channel: Non Collaborative
alice [#DarkBlue]-> alice_node: Close Channel\n<CloseChannelRequest>
alice_node [#DarkOliveGreen]-> bob_node: Final Channel Update \n<FinalChannelUpdateRequest>
...
Note over bob_node
No Response
endnote
...
alice_node [#Crimson]-> blockchain: State Register
alice_node <-[#Fuchsia] blockchain: State Registered
blockchain [#Fuchsia]-> bob_node: State Registered
...
Note over blockchain
Channel Timeout
endnote
...
alice_node [#Crimson]-> blockchain: Settle
alice_node [#Crimson]-> blockchain: Withdraw Funds
blockchain <-[#Crimson] bob_node: Withdraw Funds
alice <-[#DarkBlue] alice_node: Channel Closed\n<CloseChannelResponse>
'group
end



group Channel Dispute: Invalid State Registered
blockchain <-[#Crimson] bob_node: State Register (Invalid)
alice_node <-[#Fuchsia] blockchain: State Registered
alice_node [#Fuchsia]-> alice_node: Invalid State Registered
alice_node [#Crimson]-> blockchain: State Register (Latest)
alice_node <[#Fuchsia]- blockchain: State Registered
blockchain [#Fuchsia]-> bob_node: State Registered
...
Note over blockchain
Channel Timeout
endnote
...
alice_node [#Crimson]-> blockchain: Settle
alice_node [#Crimson]-> blockchain: Withdraw Funds
blockchain <-[#Crimson] bob_node: Withdraw Funds
alice <-[#DarkBlue] alice_node: Channel Closed\n<ChannelClosedNotification>
'group
end
'group
end

' group User session setup
' alice[#DarkBlue]->alice_node: New Session\n<usrMsgNewSessionRequest>
' alice<-[#DarkBlue]alice_node:Session setup success / failure\n<usrMsgNewSessionResponse>
' note over alice, alice_node #Pink
' Terminate on session setup failure
' end note
' 'group 
' end

' group Pre-setup 

' group Open channel
' alice[#DarkBlue]->alice_node:Open Channel with Bob\n<usrMsgNewChannelRequest>
' alice_node[#Crimson]->bob_node:Channel identity request\n<chMsgIdentityRequest>
' alice_node<-[#Crimson]bob_node:Channel identity response\n<chMsgIdentityResponse>

' opt if identityMismatch
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice<-[#DarkBlue]alice_node:New channel Identity error\n<usrMsgNewChannelResponse>
' note over alice, alice_node #Pink
' Terminate
' endnote
' 'opt if identityMismatch
' end

' alice_node[#Crimson]->bob_node:New channel request\n<chMsgNewChannelRequest>
' bob_node[#DarkBlue]->bob:New Channel request\n<usrMsgNewChannelRequest>

' alt bob does not respond
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice<-[#DarkBlue]alice_node:No response\n<usrMsgNewChannelResponse>
' note over alice, alice_node #Pink
' Terminate
' endnote

' else bob declines request
' bob[#DarkBlue]->bob_node:Decline\n<usrMsgNewChannelResponse> 
' alice_node<-[#Crimson]bob_node:New channel response declined\n<chMsgNewChannelResponse>
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice<-[#DarkBlue]alice_node:New channel request declined\n<usrMsgNewChannelResponse>
' note over alice, bob #Pink
' Terminate
' endnote

' else receiver accepts request 
' bob_node<-[#DarkBlue]bob:Accept\n<usrMsgNewChannelResponse>
' alice_node<-[#Crimson]bob_node:New channel response accepted\n<chMsgNewChannelResponse>
' alice_node[#Fuchsia]->alice_node:Set STATUS = PRESETUP
' alice<-[#DarkBlue]alice_node:New channel request accepted\n<usrMsgNewChannelResponse>

' 'alt bob does not respond
' end

' 'group Open channel
' end


' group Contracts Store Version Check
' alice_node[#Crimson]->bob_node:Contract Store\n<contractStore>
' alice_node<-[#Crimson]bob_node:Accepted / Declined\n<contractList>

' alt if accepted (on Success)
' bob_node[#Fuchsia]->bob_node:Store contract store version
' alice_node[#Fuchsia]->alice_node:Store contract store version
' else if declined (on Failure)
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice_node[#DarkBlue]->alice:Channel setup failed\nContract store version mismatch
' bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
' bob_node[#DarkBlue]->bob:Channel setup failed\nContract store version mismatch
' note over alice, bob #Pink
' Terminate
' endnote

' 'alt if accepted (on Success)
' end

' 'group Contracts Version Check
' end

' group Session Id (sid) Creation
' alice_node[#Crimson]->bob_node:Partial Session id\n<chMsgSessionId>
' alice_node<-[#Crimson]bob_node:Complete Session id\n<chMsgSessionId>
' alice_node[#Crimson]->bob_node:Session id accepted\n<chMsgSessionId>
' alice_node[#Fuchsia]->alice_node:Store session id
' bob_node[#Fuchsia]->bob_node:Store session id
' 'group Session Id (sid) Creation
' end

' group MSContract Base state Creation
' alice_node[#Crimson]->bob_node:Partially signed\nMSContract Base state\n<chMsgBaseState>
' alice_node<-[#Crimson]bob_node:Fully signed\nMSContract Base state\n<chMsgBaseState>
' alice_node[#Crimson]->bob_node:MSContract Base state accepted\n<chMsgBaseState>
' alice_node[#Fuchsia]->alice_node:Store ms contract base state
' bob_node[#Fuchsia]->bob_node:Store ms contract base state
' 'group MSContract Base state Creation
' end

' 'Share signature library address
' group Share signature library address (sign lib addr)
' alice_node[#Crimson]->bob_node:Lib signature addr\n<chMsgContractAddr>
' bob_node[#DarkOliveGreen]->bc:Verify Contract at\n<eth-addr>
' bob_node<-[#DarkOliveGreen]bc:Success / Failure
' alice_node<-[#Crimson]bob_node:Lib signature addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>

' alt if accepted (on Success)
' bob_node[#Fuchsia]->bob_node:Set STATUS = SETUP
' bob_node[#Fuchsia]->bob_node:Store lib signature address
' alice_node[#Fuchsia]->alice_node:Set STATUS = SETUP
' alice_node[#Fuchsia]->alice_node:Store lib signature address
' else if declined (on Failure)
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice_node[#DarkBlue]->alice:Channel setup failed\nLib signature address disagreement
' bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
' bob_node[#DarkBlue]->bob:Channel setup failed\nLib signature address disagreement
' note over alice_node, bob_node #Pink
' Terminate
' endnote

' 'alt if accepted (on Success)
' end

' 'group Share signature library address (sign lib addr)
' end

' 'group
' end

' group Setup

' group Deploy and share MSContract
' alice_node[#DarkOliveGreen]->bc:Deploy MSContract\n<Contract code>
' alice_node<-[#DarkOliveGreen]bc:MSContract deployed\n<Contract addr>
' alice_node[#Crimson]->bob_node:MSContract\n<chMsgContractAddr>
' bob_node[#DarkOliveGreen]->bc:Verify MSContract at\n<eth-addr>
' alice_node<-[#Crimson]bob_node:MSContract addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>
' alt if accepted (on Success)
' bob_node[#Fuchsia]->bob_node:Store ms contract address
' alice_node[#Fuchsia]->alice_node:Store ms contract address
' else if declined (on Failure)
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice_node[#DarkBlue]->alice:Channel setup failed\nMSContract address disagreement
' bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
' bob_node[#DarkBlue]->bob:Channel setup failed\nMSContract address disagreement
' note over alice_node, bob_node #Pink
' Terminate
' endnote

' 'alt if accepted (on Success)
' end

' 'group Deploy and share MSContract
' end

' note over alice_node, bob_node #DarkSeaGreen
' How nodes react is determined by their role in the channel - Sender / Receiver
' Order in which they receive events and hence react may vary in runtime
' Alice is Sender and Bob is Receiver
' endnote

' note over alice_node #DarkSeaGreen
' ROLE-CH - SENDER
' endnote

' note over bob_node #DarkSeaGreen
' ROLE-CH - RECEIVER
' endnote

' group OnEvent "MSContract Initialising"
' alice_node<-[#DarkOliveGreen]bc:MSContract Initializing\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' alice_node[#Fuchsia]->alice_node:Set STATUS = INIT
' alice_node[#Fuchsia]->alice_node:Set timer period = mscontract timeout
' alice_node[#DarkOliveGreen]->bc:MSContract:Confirm\n<call>

' 'if ROLE-CH = SENDER / RECEIVER
' end

' bob_node<-[#DarkOliveGreen]bc:MSContract Initializing\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' bob_node[#Fuchsia]->bob_node:Set STATUS = INIT
' bob_node[#Fuchsia]->bob_node:Set timer period = 1.5 * mscontract timeout
' note over bob_node #DarkSeaGreen
' 1.5 is an arbitary number.
' If Sender has not called refund event after 1.5 * t,
' then receiver will call refund
' endnote
' bob_node[#DarkOliveGreen]->bc:MSContract:Confirm\n<call>

' 'if ROLE-CH = SENDER / RECEIVER
' end

' end
' alt if both timers (sender and receiver) are yet to timeout
' |||
' group OnEvent "MSContract Initalised"
' alice_node<-[#DarkOliveGreen]bc:MSContract Initialised\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' alice_node[#Fuchsia]->alice_node:Set STATUS = OPEN
' alice_node[#Fuchsia]->alice_node:Reset and stop timer

' 'if ROLE-CH = SENDER / RECEIVER
' end

' bob_node<-[#DarkOliveGreen]bc:MSContract Initialised\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' bob_node[#Fuchsia]->bob_node:Set STATUS = OPEN
' bob_node[#Fuchsia]->bob_node:Reset and stop timer

' 'if ROLE-CH = SENDER / RECEIVER
' end

' 'group OnEvent "MSContract Initalised"
' end

' else if either alice / bob timer timesout

' group Call "MSContract Refund"
' |||
' alt if alice timer times out
' alice_node<-[#Fuchsia]alice_node:MSContract TimedOut\nat period = mscontract timeout

' opt if STATUS = OPEN AND ROLE-CH = SENDER
' alice_node[#DarkOliveGreen]->bc:MSContract:Refund\n<call>

' 'opt if STATUS = OPEN AND ROLE-CH = SENDER
' end

' else if bob timer times out
' bob_node<-[#Fuchsia]bob_node:MSContract TimedOut\nat period = 1.5 * mscontract timeout

' opt if STATUS = OPEN AND ROLE-CH = RECEIVER
' bob_node[#DarkOliveGreen]->bc:MSContract:Refund\n<call>

' 'opt if STATUS = OPEN AND ROLE-CH = SENDER
' end

' 'alt if alice timer times out
' end


' alice_node<-[#DarkOliveGreen]bc:MSContract Refunded\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice_node[#DarkBlue]->alice:Channel setup failed\nTimedout before confirm
' note over alice, alice_node #Pink
' Terminate
' endnote

' 'if ROLE-CH = SENDER / RECEIVER
' end

' bob_node<-[#DarkOliveGreen]bc:MSContract Refunded\n<event>
' opt if ROLE-CH = SENDER / RECEIVER
' bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
' bob_node[#DarkBlue]->bob:Channel setup failed\nTimedout before confirm
' note over bob, bob_node #Pink
' Terminate
' endnote

' 'if ROLE-CH = SENDER / RECEIVER
' end

' 'group OnTimeout call "MSContract Refund"
' end

' 'alt
' end

' 'group
' end

' group Setup VPC

' alice_node[#DarkOliveGreen]->bc:Deploy VPC\n<Contract code>
' alice_node<-[#DarkOliveGreen]bc:VPC deployed\n<Contract addr>
' alice_node[#Crimson]->bob_node:VPC\n<chMsgContractAddr>
' bob_node[#DarkOliveGreen]->bc:Verify VPC at\n<eth-addr>
' alice_node<-[#Crimson]bob_node:VPC addr\naccepted (on Success) / declined (on Failure)\n<chMsgContractAddr>
' alt if accepted (on Success)
' bob_node[#Fuchsia]->bob_node:Store vpc address
' alice_node[#Fuchsia]->alice_node:Store vpc address
' else if declined (on Failure)
' alice_node[#DarkBlue]->alice:Channel setup failed\nVPC address disagreement
' bob_node[#DarkBlue]->bob:Channel setup failed\nVPC address disagreement
' note over alice_node, bob_node #Pink
' Terminate
' endnote

' 'alt if accepted (on Success)
' end

' alice_node[#DarkOliveGreen]->bc:MSContract:State register\n<call>

' group OnEvent "MSContract State Registering"
' bc[#DarkOliveGreen]->alice_node:State registering\n<event>
' opt if ROLE-CH = SENDER AND STATUS = OPEN
' alice_node[#Fuchsia]->alice_node:Set STATUS = INCONFLICT
' alice_node[#Fuchsia]->alice_node:Set timer period = mscontract timeout

' 'opt if ROLE-CH = SENDER
' end

' bc[#DarkOliveGreen]->bob_node:State registering\n<event>
' opt if ROLE-CH = SENDER AND STATUS = OPEN
' bob_node[#DarkOliveGreen]->bc:MSContract:State register\n<call>
' bob_node[#Fuchsia]->bob_node:Set STATUS = INCONFLICT

' 'opt if ROLE-CH = SENDER
' end

' 'group OnEvent "MSContract State Registering"
' end


' group OnEvent "MSContract State Registered"

' bc[#DarkOliveGreen]->alice_node:State registered\n<event> 
' opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
' alice_node[#Fuchsia]->alice_node:Set STATUS = SETTLED
' alice<-[#DarkBlue]alice_node:Channel setup successful\n<chMsgMSCBaseState>

' 'opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
' end

' bc[#DarkOliveGreen]->bob_node:State registered\n<event> 
' opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
' bob_node[#Fuchsia]->bob_node:Set STATUS = SETTLED
' bob<-[#DarkBlue]bob_node:Channel setup successful\n<chMsgMSCBaseState>

' 'opt if ROLE-CH = SENDER/RECEIVER AND STATUS = INCONFLICT
' end

' 'group OnEvent "MSContract State Registered"
' end

' note over alice, bob #DarkSeaGreen
' Channel is setup. Parties can transact by creating new vpc states and signing them
' As many transactions as required can be done. One sample for each party is shown below
' endnote

' 'group Setup VPC
' end

' group Exchange state initated by alice

' alice[#DarkBlue]->alice_node:Proposed new state\n<usrMsgState>
' alice_node[#Crimson]->bob_node:Partially signed state\n<chMsgState>
' bob_node[#DarkBlue]->bob:Confirm new state\n<usrMsgState>

' alt if bob confirms new state
' bob_node<-[#DarkBlue]bob:Confirmed new state\n<usrMsgState>
' bob_node[#Fuchsia]->bob_node:Update state\n<state>
' alice_node<-[#Crimson]bob_node:Fully signed state\n<chMsgState>
' alice_node[#Fuchsia]->alice_node:Update state\n<state>
' alice<-[#DarkBlue]alice_node:Confirmed new state<useMsgState>

' else if bob declines new state
' bob_node<-[#DarkBlue]bob:Reject new state\n<usrMsgState>
' alice_node<-[#Crimson]bob_node:Rejected new state\n<chMsgState>
' alice<-[#DarkBlue]alice_node:Rejected new state\n<useMsgState>

' 'alt
' end

' 'group
' end

' group Exchange state initated by bob

' bob[#DarkBlue]->bob_node:Proposed new state\n<usrMsgState>
' bob_node[#Crimson]->alice_node:Partially signed state\n<chMsgState>
' alice_node[#DarkBlue]->alice:Confirm new state\n<usrMsgState>

' alt if alice confirms new state
' alice_node<-[#DarkBlue]alice:Confirmed new state\n<usrMsgState>
' alice_node[#Fuchsia]->alice_node:Update state\n<state>
' bob_node<-[#Crimson]alice_node:Fully signed state\n<chMsgState>
' bob_node[#Fuchsia]->bob_node:Update state\n<state>
' bob<-[#DarkBlue]bob_node:Confirmed new state<useMsgState>

' else if alice declines new state
' alice_node<-[#DarkBlue]alice:Reject new state\n<usrMsgState>
' bob_node<-[#Crimson]alice_node:Rejected new state\n<chMsgState>
' bob<-[#DarkBlue]bob_node:Rejected new state\n<useMsgState>

' 'alt
' end

' 'group
' end

' group Close channel

' alice[#DarkBlue]->alice_node:Close channel\n<usrMsgFinaliseState>
' alice_node[#Fuchsia]->alice_node:Set ROLE-CL = SENDER

' alice_node[#DarkOliveGreen]->bc:VPC Contract:Close\n<call>


' group OnEvent "VPC Closing"

' alice_node<-[#DarkOliveGreen]bc:VPC Closing\n<event>
' opt if ROLE-CL = SENDER AND STATUS = SETTLED
' alice_node[#Fuchsia]->alice_node:Set STATUS = VPCCLOSING
' alice_node[#Fuchsia]->alice_node:Set time period = vpc-extended-validity

' 'opt if ROLE-CL = SENDER AND STATUS = SETTLED
' end

' bob_node<-[#DarkOliveGreen]bc:VPC Closing\n<event>
' opt if ROLE-CL != SENDER AND STATUS = SETTLED
' bob_node[#Fuchsia]->bob_node:Set ROLE-CL = RECEIVER
' bob_node[#Fuchsia]->bob_node:Set STATUS = VPCCLOSING
' bob_node[#Fuchsia]->bob_node:Set time period = vpc validity

' alt if close mode = manual
' bob_node[#DarkBlue]->bob:Close call received with state\n<usrMsgFinaliseState>
' bob_node<-[#DarkBlue]bob:Respond to close call\n<usrMsgFinaliseState>

' opt if Response == call close

' alt if now < timeout
' bob_node[#Fuchsia]->bob_node:Reset and stop timer
' bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\final state\n<call>
' bob_node[#DarkBlue]->bob:Close called\n<usrMsgFinaliseStateClose>
' else if now > timeout
' bob_node[#DarkBlue]->bob:Cannot close - validity timer expired\n<usrMsgFinaliseStateClose>

' 'opt if Response == call close
' end

' 'alt if now < timeout
' end

' else if close mode = auto-normal / auto-immediate

' alt if closing state != current state
' bob_node[#Fuchsia]->bob_node:Reset and stop timer
' bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\correct final state\n<call>
' else if closing_state == current_state AND close mode = auto-immediate
' bob_node[#Fuchsia]->bob_node:Reset and stop timer
' bc<-[#DarkOliveGreen]bob_node:VPC Contract:Close\nsame state\n<call>

' 'alt if closing state != current state
' end

' 'alt if close mode = manual
' end

' 'opt if ROLE-CL = RECEIVER AND STATUS = SETTLED
' end

' 'group OnEvent "MSContract State Registering"
' end

' alt if SENDER times out and no event received
' opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING AND VPC EXTENDED VALIDITY TIMEDOUT
' alice_node[#Fuchsia]->alice_node:vpc extended validity timedout
' alice_node[#DarkOliveGreen]->bc:MSC Contract:Execute\n<call>

' 'opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
' end

' else if VPCClosed Event is received

' group OnEvent "VPC Closed"

' alice_node<-[#DarkOliveGreen]bc:VPC Closed\n<event>
' opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
' alice_node[#Fuchsia]->alice_node:Set STATUS = VPCCLOSED
' alice_node[#Fuchsia]->alice_node:Reset and stop timer
' alice_node[#DarkOliveGreen]->bc:MSC Contract:Execute\n<call>

' 'opt if ROLE-CL = SENDER AND STATUS = VPCCLOSING
' end

' bob_node<-[#DarkOliveGreen]bc:VPC Closed\n<event>
' opt if ROLE-CL = RECIEVER AND STATUS = VPCCLOSING
' bob_node[#Fuchsia]->bob_node:Set STATUS = VPCCLOSED

' 'opt if ROLE-CL = SENDER AND STATUS = SETTLED
' end

' 'group OnEvent "VPC Closed"
' end

' 'alt if SENDER times out and no event received
' end

' group OnEvent "MSContract Closed"
' alice_node<-[#DarkOliveGreen]bc:MSContract Closed\n<event>
' opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
' alice_node[#Fuchsia]->alice_node:Set STATUS = CLOSED
' alice_node[#DarkBlue]->alice:Channel closed\n<usrMsgChannelClosed>
' note over alice, alice_node #Pink
' Terminate
' endnote

' 'opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
' end

' bc[#DarkOliveGreen]->bob_node:MSContract Closed\n<event>
' opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
' bob_node[#Fuchsia]->bob_node:Set STATUS = CLOSED
' bob_node[#DarkBlue]->bob:Channel closed\n<usrMsgChannelClosed>
' note over bob, bob_node #Pink
' Terminate
' endnote

' 'opt if ROLE-CH = SENDER AND STATUS = VPCCLOSED
' end

' 'group OnEvent "MSContract Closed"
' end

' 'group Close channel
' end

' note over alice, bob #DarkSeaGreen
' ROLE-CH : Role in channel.  SENDER/RECEIVER
' ROLE-CL : Role in close.    SENDER/RECEIVER
' endnote

@enduml
