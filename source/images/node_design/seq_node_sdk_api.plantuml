@startuml seq_node_sdk_api
Title Sequence Diagram - Interaction among node, sdk and api.

actor alice
entity "Alice's\nPerun Node" as alice_node
entity sdk


skinparam sequence {
    messageAlign center
    ArrowThickness 2
    BoxBorderColor Sienna
    BoxBackgroundColor SeaShell
    GroupBodyBackgroundColor transparent
    NoteTextAlignment center
    DefaultTextAlignment center
}
hide footbox

group Establish Session
alice [#DarkBlue]-> alice_node:New Session\n<NewSessionRequest>
alice_node [#DarkOliveGreen]-> sdk:bus.New
alice_node [#DarkOliveGreen]-> sdk:client.New
alice_node [#Crimson]-> alice_node:Start listeners, Handlers
alice <-[#DarkBlue] alice_node:New Session\n<NewSessionResponse>
'group
end

group OPEN PHASE
group Open Channel
alice [#DarkBlue]-> alice_node: Send Channel Proposal\n<SendChannelProposalRequest>
alice_node [#Crimson]-> alice_node: Generate Nonce
alice_node [#DarkOliveGreen]-> sdk: client.ProposeChannel
opt if no error
alice_node [#Crimson]-> alice_node: Push Channel\nto Channels
'if
end
alice <-[#DarkBlue] alice_node: Send Channel Proposal\n<ChannelProposalResponse>
'group
end

group Incoming Request
alice_node <-[#DarkOliveGreen] sdk: ProposalHandler\n(callback)
alice_node [#Crimson]-> alice_node: Push ProposalResponder\nto ProposalResponders
alice <-[#DarkBlue] alice_node: Channel Proposal Notification\n<ChannelProposalNotification>
...
alice [#DarkBlue]-> alice_node: Receive Channel Proposal\n<ReceiveChannelProposalRequest>
alice_node [#Crimson]-> alice_node: Pop out from ProposalResponders
alt if timeout not expired
alice_node [#DarkOliveGreen]-> sdk: Responder.(Accept/Reject)
opt if Accept & no error
alice_node [#Crimson]-> alice_node: Push Channel\nto Channels
'if
end
else if timeout expired
alice <-[#DarkBlue] alice_node: Receive Channel Proposal\n<ChannelProposalResponse>
'if
end
'group
end
'group
end

group TRANSACT PHASE
group Transact: Send Payment
alice [#DarkBlue]-> alice_node: Send Payment\n<SendPaymentRequest>
alice_node [#DarkOliveGreen]-> sdk: channel.UpdateBy
opt if no error
alice_node [#Crimson]-> alice_node: Update last state in Channels
'if
end
alice <-[#DarkBlue] alice_node: Send Payment\n<PaymentResponse>
'group
end

Note over alice_node #LightGray
If same version state is incoming & outgoing
which one to drop, which one to accept ?
Check what logic sdk does ?
endnote

group Transact: Receive Payment
alice_node <-[#DarkOliveGreen] sdk: UpdateHandler\n(callback)
alice_node [#Crimson]-> alice_node: Push UpdateResponder\nto UpdateResponders
opt if Final Update
alice_node [#Crimson]-> alice_node: ChannelLock = Finalized.
alice_node [#Crimson]-> alice_node: Start Settle time
Note over alice_node #LightGray
Wait for channel to be settled by peer until
2 x TxTimeout, if no watcher is still running,
initialize settle.
endnote

'if
end
alice <-[#DarkBlue] alice_node: Receive Payment\n<PaymentNotification>
...
alice [#DarkBlue]-> alice_node: Receive Payment\n<ReceivePaymentRequest>
alice_node [#Crimson]-> alice_node: Pop out UpdateResponder\nfrom UpdateResponders
alt if timeout not expired
alice_node [#DarkOliveGreen]-> sdk: Responder.(Accept/Reject)
opt if Accept & no error
alice_node [#Crimson]-> alice_node: Drop Responders\nfor previous versions\nof the channel state.
alice_node [#Crimson]-> alice_node: Update last state in Channels
'if
end
else if timeout expired
alice_node [#Crimson]-> alice_node: Drop Responders\nfor previous versions\nof the channel state.
alice <-[#DarkBlue] alice_node: Receive Payment\n<PaymentResponse>
'alt
end
'group
end
'group
end

group SETTLE PHASE

group Close Channel: Collaborative or Non Collaborative
alice [#DarkBlue]-> alice_node: Close Channel\n<CloseChannelRequest>
alice_node [#Crimson]-> alice_node: ChannelLock = Closed.
Note over alice_node #LightGray
Called when user / sdk sends a final update.
Once locked, State Update cannot be called
When final, further updates requests should be rejected.
endnote
alice_node [#DarkOliveGreen]-> sdk: Channel.UpdateBy (as final)
Note over alice_node, sdk #LightGray
Response from UpdateBy:
        Success -> Collaborative Close in Settle
        Error -> Non Collaborative Close in Settle
Difference will be only in return time of Settle.
endnote
alice_node [#DarkOliveGreen]-> sdk: Channel.Settle
alice_node [#DarkOliveGreen]-> sdk: Channel.Close
alice <-[#DarkBlue] alice_node: Close Channel\n<CloseChannelResponse>
'group
end

group Channel Closed by Peer (Collaborative or Non Collaborative)

alice_node <-[#DarkOliveGreen] sdk: channel.Watch returns
alt if ChannelLock == Closed (Closed initiated by user)
alice_node [#Crimson]-> alice_node: Log a message & Ignore.
else if ChannelLock == Unlocked or Finalized
alice_node [#Crimson]-> alice_node: ChannelLock = Closed.
alice_node [#Crimson]-> alice_node: Fetch last known state of channel.
alice_node [#DarkOliveGreen]-> sdk: Channel.Close
alice <-[#DarkBlue] alice_node: Close Channel\n<ChannelClosedNotification>
Note over alice_node #LightGray
Watch returns with error = nil if channel was successfully withdrawn.
If it returns with error, lock the channel and notify the user with error message.
Because no specific errors are define by the SDK.
endnote
'alt
end


'group
end
'group
end

Note over alice, sdk #LightGrey
DataStructure: Channels:
    map of channelID to
    struct with
        last known state (contains version, balance)
        channel object
        map of version to Responders

DataStructure: UpdateResponders: nested map of version to Reponsders against channelID in Channels

DataStructure: ProposalResponders: map of proposal id to Reponsders

ChannelLock: Enum (Unlocked, Finalized, Locked)
- Unlocked: Open for transactions.
- Finalized: Final state sent by peer.
- Locked: Closed for transactions.

endnote

@enduml
